<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1421879951719">{:repl-history {:ide [], :local [&quot;(ns network-six.util\n  (:require [clojure.string :as string]\n            [clojure.set :as set]))\n\n(defn mean [coll]\n  (let [\n        ;; Traverse a collection, count size one by one,\n        ;; calculate sum step by step\n        accum (fn [[sum size] n]\n                   [(+ sum n) (inc size)])\n        ;; Calculate mean\n        calc-mean (fn [[sum size]] (/ sum size))]\n    (calc-mean\n      (reduce accum [0 0] coll))))\n\n(defn median [coll]\n  (let [n (count coll), i (quot n 2)]\n    (if (zero? (mod n 2))\n      (nth coll i)\n      (/ (+ (nth coll i) (nth coll (inc i))) 2.0))))\n\n(defn log\n  [src &amp; args]\n  (print (str (string/join \&quot; \&quot; (concat [\\[ (str (java.util.Date.)) \\] src]\n                                       (map str args)))\n              \&quot;\\n\&quot;))\n  (flush))\n\n(defn log-every\n  [n m src &amp; args]\n  (when (zero? (mod n m))\n    (apply log src args)))\n\n(defn group-seq\n  \&quot;This is a lazy very of group-by. Instead of returning a map, it returns a\n  seq of [key [value]] pairs.\&quot;\n  [key-fn coll]\n  (let [step (fn step [xs]\n               (when-let [s (seq xs)]\n                 (let [k (key-fn (first s))\n                       [head-xs tail-xs] (split-with #(= k (key-fn %)) s)]\n                   (cons [k head-xs] (step tail-xs)))))]\n    (lazy-seq (step coll))))\n\n(defn trim-dot\n  \&quot;This removes any trailing dots from a string.\&quot;\n  [s]\n  (if (.endsWith s \&quot;.\&quot;)\n    (.substring s 0 (- (.length s) 1))\n    s))\n\n(defn numbered\n  [coll]\n  (map vector (range) coll))\n\n(defn arg-value\n  ([args opt-key] (arg-value args opt-key nil))\n  ([args opt-key default]\n   (let [opt-str (str \&quot;--\&quot; (name opt-key))]\n     (if-let [opt (first (filter #(.startsWith % opt-str) args))]\n       (second (string/split opt #\&quot;=\&quot;))\n       default))))\n\n(defn set-diff [a b]\n  [(set/difference a b) (set/difference b a)])\n&quot; &quot;(numbered [1 2 3 99])&quot; &quot;(def x [1 2 3 99])&quot; &quot;(numbered x)&quot; &quot;((range) x)&quot; &quot;(vector (range) x)&quot; &quot;\n(ns network-six.util\n  (:require [clojure.string :as string]\n            [clojure.set :as set]))\n\n(defn mean [coll]\n  (let [\n        ;; Traverse a collection, count size one by one,\n        ;; calculate sum step by step\n        accum (fn [[sum size] n]\n                   [(+ sum n) (inc size)])\n        ;; Calculate mean\n        calc-mean (fn [[sum size]] (/ sum size))]\n    (calc-mean\n      (reduce accum [0 0] coll))))\n\n(defn median [coll]\n  (let [n (count coll), i (quot n 2)]\n    (if (zero? (mod n 2))\n      (nth coll i)\n      (/ (+ (nth coll i) (nth coll (inc i))) 2.0))))\n\n(defn log\n  [src &amp; args]\n  (print (str (string/join \&quot; \&quot; (concat [\\[ (str (java.util.Date.)) \\] src]\n                                       (map str args)))\n              \&quot;\\n\&quot;))\n  (flush))\n\n(defn log-every\n  [n m src &amp; args]\n  (when (zero? (mod n m))\n    (apply log src args)))\n\n(defn group-seq\n  \&quot;This is a lazy very of group-by. Instead of returning a map, it returns a\n  seq of [key [value]] pairs.\&quot;\n  [key-fn coll]\n  (let [step (fn step [xs]\n               (when-let [s (seq xs)]\n                 (let [k (key-fn (first s))\n                       [head-xs tail-xs] (split-with #(= k (key-fn %)) s)]\n                   (cons [k head-xs] (step tail-xs)))))]\n    (lazy-seq (step coll))))\n\n(defn trim-dot\n  \&quot;This removes any trailing dots from a string.\&quot;\n  [s]\n  (if (.endsWith s \&quot;.\&quot;)\n    (.substring s 0 (- (.length s) 1))\n    s))\n\n(defn numbered\n  [coll]\n  (map vector (range) coll))\n(def x [1 2 3 99])\n(numbered x)\n(vector (range) x)\n\n(defn arg-value\n  ([args opt-key] (arg-value args opt-key nil))\n  ([args opt-key default]\n   (let [opt-str (str \&quot;--\&quot; (name opt-key))]\n     (if-let [opt (first (filter #(.startsWith % opt-str) args))]\n       (second (string/split opt #\&quot;=\&quot;))\n       default))))\n\n(defn set-diff [a b]\n  [(set/difference a b) (set/difference b a)])\n\n&quot; &quot;\n(ns network-six.util\n  (:require [clojure.string :as string]\n            [clojure.set :as set]))\n\n(defn mean [coll]\n  (let [\n        ;; Traverse a collection, count size one by one,\n        ;; calculate sum step by step\n        accum (fn [[sum size] n]\n                   [(+ sum n) (inc size)])\n        ;; Calculate mean\n        calc-mean (fn [[sum size]] (/ sum size))]\n    (calc-mean\n      (reduce accum [0 0] coll))))\n\n(defn median [coll]\n  (let [n (count coll), i (quot n 2)]\n    (if (zero? (mod n 2))\n      (nth coll i)\n      (/ (+ (nth coll i) (nth coll (inc i))) 2.0))))\n\n(defn log\n  [src &amp; args]\n  (print (str (string/join \&quot; \&quot; (concat [\\[ (str (java.util.Date.)) \\] src]\n                                       (map str args)))\n              \&quot;\\n\&quot;))\n  (flush))\n\n(defn log-every\n  [n m src &amp; args]\n  (when (zero? (mod n m))\n    (apply log src args)))\n\n(defn group-seq\n  \&quot;This is a lazy very of group-by. Instead of returning a map, it returns a\n  seq of [key [value]] pairs.\&quot;\n  [key-fn coll]\n  (let [step (fn step [xs]\n               (when-let [s (seq xs)]\n                 (let [k (key-fn (first s))\n                       [head-xs tail-xs] (split-with #(= k (key-fn %)) s)]\n                   (cons [k head-xs] (step tail-xs)))))]\n    (lazy-seq (step coll))))\n\n(defn trim-dot\n  \&quot;This removes any trailing dots from a string.\&quot;\n  [s]\n  (if (.endsWith s \&quot;.\&quot;)\n    (.substring s 0 (- (.length s) 1))\n    s))\n\n(defn numbered\n  [coll]\n  (map vector (range) coll))\n(def x [1 2 3 99])\n(numbered x)&quot; &quot;(map vector (range) x)&quot; &quot;(take 5 (range))&quot; &quot;(defn drop-one\n  [coll]\n  (when-let [s (seq coll)]\n    (rest s)))\n(drop-one [1 2 3])\n(drop-one [])&quot; &quot;(split-with #(&gt;= 3 %) [1 2 3 4 5])&quot; &quot;(split-with #(&gt;= 3 %) [1 2 3 4 5 1 2 3])&quot; &quot;(split-with #(== 3 %) [1 2 3 4 5 1 2 3])&quot; &quot;(split-with #(== 3 %) [3 3 3 4 5 1 2 3])&quot; &quot;(defn group-seq\n  \&quot;This is a lazy very of group-by. Instead of returning a map, it returns a\n  seq of [key [value]] pairs.\&quot;\n  [key-fn coll]\n  (let [step (fn step [xs]\n               (when-let [s (seq xs)]\n                 (let [k (key-fn (first s))\n                       [head-xs tail-xs] (split-with #(= k (key-fn %)) s)]\n                   (cons [k head-xs] (recur tail-xs)))))]\n    (lazy-seq (step coll))))&quot; &quot;(defn group-seq\n  \&quot;This is a lazy very of group-by. Instead of returning a map, it returns a\n  seq of [key [value]] pairs.\&quot;\n  [key-fn coll]\n  (let [step (fn step [xs]\n               (when-let [s (seq xs)]\n                 (let [k (key-fn (first s))\n                       [head-xs tail-xs] (split-with #(= k (key-fn %)) s)]\n                   (cons [k head-xs] (step tail-xs)))))]\n    (lazy-seq (step coll))))\n(group-seq identity [1 1 1 2 2 2 3 3 3])&quot; &quot;(group-by identity [1 1 1 2 2 2 3 3 3])&quot; &quot;(source group-by)&quot; &quot;(defn group-seq\n  [key-fn coll]\n  (let [\n        ;; get the first key of a collection\n        first-key (fn [x] key-fn (first x))\n        step (fn [xs]\n               (let [k (first-key xs) \n                     [grouped not-grouped] (split-with #(= k (key-fn %)) xs)]\n                 (cons grouped (step xs))))\n        ])\n  (lazy-seq (step coll)))&quot; &quot;(defn group-seq\n  [key-fn coll]\n  (let [\n        ;; get the first key of a collection\n        first-key (fn [x] key-fn (first x))\n        step (fn step [xs]\n               (let [k (first-key xs) \n                     [grouped not-grouped] (split-with #(= k (key-fn %)) xs)]\n                 (cons grouped (step xs))))\n        ])\n  (lazy-seq (step coll)))&quot; &quot;(defn group-seq\n  [key-fn coll]\n  (let [\n        ;; get the first key of a collection\n        first-key (fn [x] key-fn (first x))\n        step (fn [xs]\n               (let [k (first-key xs)\n                     [grouped not-grouped] (split-with #(= k (key-fn %)) xs)]\n                 (cons grouped (step xs))))\n        ]\n    (lazy-seq (step coll))))&quot; &quot;(defn group-seq\n  [key-fn coll]\n  (let [\n        ;; get the first key of a collection\n        first-key (fn [x] key-fn (first x))\n        step (fn step [xs]\n               (let [k (first-key xs)\n                     [grouped not-grouped] (split-with #(= k (key-fn %)) xs)]\n                 (cons grouped (step xs))))\n        ]\n    (lazy-seq (step coll))))&quot; &quot;(group-seq [1 1 1 2 2 2 3 3 3])&quot; &quot;(group-seq identity [1 1 1 2 2 2 3 3 3])&quot; &quot;(defn group-seq\n  [key-fn coll]\n  (let [\n        ;; get the first key of a collection\n        first-key (fn [x] key-fn (first x))\n        step (fn step [xs]\n               (let [k (first-key xs)\n                     [grouped not-grouped] (split-with #(= k (key-fn %)) xs)]\n                 (cons grouped (step not-grouped))))\n        ]\n    (lazy-seq (step coll))))\n(group-seq identity [1 1 1 2 2 2 3 3 3])&quot; &quot;(defn group-seq\n  [key-fn coll]\n  (let [\n        ;; get the first key of a collection\n        first-key (fn [x] key-fn (first x))\n        step (fn step [xs]\n               (let [k (first-key xs)\n                     [grouped not-grouped] (split-with #(= k (key-fn %)) xs)]\n                 (cons [k grouped] (step not-grouped))))\n        ]\n    (lazy-seq (step coll))))\n(group-seq identity [1 1 1 2 2 2 3 3 3])&quot; &quot;(use 'clojure.contrib.trace)&quot; &quot;(defn group-seq\n  [key-fn coll]\n  (let [\n        ;; get the first key of a collection\n        first-key (fn [x] key-fn (first x))\n        step (fn step [xs]\n               (let [k (first-key xs)\n                     _ (println k)\n                     [grouped not-grouped] (split-with #(= k (key-fn %)) xs)\n                     _ (println grouped)\n                     _ (println not-grouped)]\n                 (cons [k grouped] (step not-grouped))))\n        ]\n    (lazy-seq (step coll))))\n(group-seq identity [1 1 1 2 2 2 3 3 3])&quot; &quot;(ns network-six.util\n  (:require [clojure.string :as string]\n            [clojure.set :as set]\n            [org.clojure/tools.trace \&quot;0.7.8\&quot;]))&quot; &quot;(defn group-seq\n  [key-fn coll]\n  (let [\n        ;; get the first key of a collection\n        first-key (fn [x] key-fn (first x))\n        step (fn step [xs]\n               (let [k (first-key xs)\n                     _ (println k)\n                     [grouped not-grouped] (split-with #(= k (key-fn %)) xs)\n                     _ (println grouped)\n                     _ (println not-grouped)]\n                 (cons [k grouped] (step not-grouped))))\n        ]\n    (lazy-seq (step coll))))\n(group-seq identity [1 1 1 2 2 2 3 3 3])\n(use 'clojure.tools.trace)\n(trace (group-seq identity [1 1 1 2 2 2 3 3 3]))&quot; &quot;(defn f1 [xs]\n  (let [k (first xs)]\n    (split-with #(= k %) xs)))&quot; &quot;(f1 [1 1 2 2 2])&quot; &quot;(defn f1 [xs]\n  (let [k (first xs)]\n    (vector k (split-with #(= k %) xs))))\n(f1 [1 1 2 2 2])&quot; &quot;(defn f1 [xs]\n  (let [k (first xs)\n        [g1 g2] (split-with #(= k %) xs)]\n     (cons [k g1] [g2])))\n(f1 [1 1 2 2 2])&quot; &quot;(defn triang-num [n]\n  (loop [sum 0\n         start 0]\n    (if (&gt; start n)\n      sum\n      (recur (+ sum start) (inc start)))))\n(triang-num 5)&quot; &quot;(use 'clojure.tools.trace)&quot; &quot;(trace (group-seq identity [1 1 1 2 2 2 3 3 3]))&quot; &quot;(defn group-seq\n  \&quot;This is a lazy version of group-by. Instead of returning a map, it returns a\n  seq of [key [value]] pairs.\&quot;\n  [key-fn coll]\n  (let [step (fn step [xs]\n               (let [s (seq xs)]\n                 (let [k (key-fn (first s))\n                       [head-xs tail-xs] (split-with #(= k (key-fn %)) s)]\n                   (cons [k head-xs] (step tail-xs)))))]\n    (lazy-seq (step coll))))\n(group-seq identity [1 1 1 2 2 2 3 3 3])\n;(group-by identity [1 1 1 2 2 2 3 3 3])&quot; &quot;(cons 1 [1 2])&quot; &quot;(conj 1 [1 2])&quot; &quot;(defn group-seq\n  [key-fn coll]\n  (let [\n        ;; get the first key of a collection\n        first-key (fn [x] key-fn (first x))\n        step (fn step [ys]\n               (when-let [xs (seq ys)]\n                 (let [k (first-key xs)\n                       _ (println k)\n                       [grouped not-grouped] (split-with #(= k (key-fn %)) xs)\n                       _ (println grouped)\n                       _ (println not-grouped)]\n                   (cons [k grouped] (step not-grouped)))))\n        ]\n    (lazy-seq (step coll))))\n(group-seq identity [1 1 1 2 2 2 3 3 3])&quot; &quot;(defn group-seq\n  [key-fn coll]\n  (let [\n        ;; get the first key of a collection\n        first-key (fn [x] key-fn (first x))\n        step (fn step [ys]\n               (when-let [xs (seq ys)]\n                 (let [k (first-key xs)\n                       _ (println k)\n                       [grouped not-grouped] (split-with #(= k (key-fn %)) xs)\n                       ]\n                   (cons [k grouped] (step not-grouped)))))\n        ]\n    (lazy-seq (step coll))))\n(group-seq identity [1 1 1 2 2 2 3 3 3])&quot; &quot;(defn group-seq\n  [key-fn coll]\n  (let [\n        ;; get the first key of a collection\n        first-key (fn [x] key-fn (first x))\n        step (fn step [ys]\n               (when-let [xs (seq ys)]\n                 (let [k (first-key xs)\n                       [grouped not-grouped] (split-with #(= k (key-fn %)) xs)]\n                   (cons [k grouped] (step not-grouped)))))\n        ]\n    (lazy-seq (step coll))))\n(group-seq identity [1 1 1 2 2 2 3 3 3])&quot; &quot;(empty? [])&quot; &quot;(defn group-seq\n  \&quot;This is a lazy version of group-by. Instead of returning a map, it returns a\n  seq of [key [value]] pairs.\&quot;\n  [key-fn coll]\n  (let [step (fn step [xs]\n               (when-let [s (seq xs)]\n                 (let [k (key-fn (first s))\n                       [head-xs tail-xs] (split-with #(= k (key-fn %)) s)]\n                   (cons [k head-xs] (step tail-xs)))))]\n    (lazy-seq (step coll))))\n(group-seq identity [1 1 1 2 2 2 3 3 3])\n;(group-by identity [1 1 1 2 2 2 3 3 3])&quot; &quot;(defn group-seq\n  [coll]\n  (loop [xs coll\n         groups []]\n    (if (empty? xs)\n      groups\n      (let [k (first xs)\n            [g1 g2] (split-with #(= k %) xs)\n            ]\n        (recur g2 (cons [k g1] groups))))))\n(group-seq [1 1 1 2 2 2 3 3 3 4 5 5])&quot; &quot;(defn group-seq\n  [coll]\n  (loop [xs coll\n         groups []]\n    (if (empty? xs)\n      groups\n      (let [k (first xs)\n            [g1 g2] (split-with #(= k %) xs)\n            ]\n        (recur g2 (conj groups [k g1]))))))\n(group-seq [1 1 1 2 2 2 3 3 3 4 5 5])&quot; &quot;;; a simplified group-seq\n(defn group-seq\n  [key-fn coll]\n  (loop [xs coll\n         groups []]\n    (if (empty? xs)\n      groups\n      (let [k (key-fn (first xs))\n            [g1 g2] (split-with #(= k (key-fn %)) xs)\n            ]\n        (recur g2 (conj groups [k g1]))))))\n(group-seq identity [1 1 1 2 2 2 3 3 3 4 5 5])&quot; &quot;;; a simplified group-seq\n(defn group-seq\n  [key-fn coll]\n  (loop [xs coll\n         groups []]\n    (if (empty? xs)\n      groups\n      (let [k (key-fn (first xs))\n            [g1 g2] (split-with #(= k (key-fn %)) xs)]\n        (recur g2 (conj groups [k g1]))))))\n(group-seq identity [1 1 1 2 2 2 3 3 3 4 5 5])&quot; &quot;;; a simplified group-seq\n(defn group-seq\n  [key-fn coll]\n  (loop [xs coll\n         groups []]\n    (if (empty? xs)\n      groups\n      (let [k (key-fn (first xs))\n            [g1 g2] (split-with #(= k (key-fn %)) xs)]\n        (recur g2 (conj groups [k g1]))))))\n(group-seq #(str \&quot;hello\&quot; %) [1 1 1 2 2 2 3 3 3 4 5 5])&quot; &quot;(defn trim-dot\n  \&quot;This removes any trailing dots from a string.\&quot;\n  [s]\n  (if (.endsWith s \&quot;.\&quot;)\n    (.substring s 0 (- (.length s) 1))\n    s))&quot; &quot;(trim-dot \&quot;ss...\&quot;)&quot; &quot;(defn group-seq-strict\n  [key-fn coll]\n  (loop [xs coll\n         groups []]\n    (if (empty? xs)\n      groups\n      (let [k (key-fn (first xs))\n            [g1 g2] (split-with #(= k (key-fn %)) xs)]\n        (recur g2 (conj groups [k g1]))))))&quot; &quot;(group-seq #(str \&quot;hello\&quot; %) [1 1 1 2 2 2 3 3 3 4 5 5])&quot; &quot;(time (doseq [_ (range 100)] (take 5 (group-seq #(str \&quot;hello\&quot; %) (range 1000000)))))&quot; &quot;;; another version of group-seq using loop recur\n(defn group-seq-strict\n  [key-fn coll]\n  (loop [xs coll\n         groups []]\n    (if (empty? xs)\n      groups\n      (let [k (key-fn (first xs))\n            [g1 g2] (split-with #(= k (key-fn %)) xs)]\n        (recur g2 (conj groups [k g1]))))))\n(defn group-seq\n  [&amp; args]\n  (lazy-seq (apply group-seq-strict args)))&quot; &quot;(group-seq #(str \&quot;hello\&quot; %) (range 100))&quot; &quot;(take 5 (group-seq #(str \&quot;hello\&quot; %) (range 100)))&quot; &quot;(time (doseq [_ (range 100)] (take 5 (group-seq #(str \&quot;hello\&quot; %) (range 100)))))&quot; &quot;(time (doseq [_ (range 100)] (take 5 (group-seq #(str \&quot;hello\&quot; %) (range 1000)))))&quot; &quot;(time (doseq [_ (range 100)] (take 5 (group-seq #(str \&quot;hello\&quot; %) (range 10000)))))&quot; &quot;(time (doseq [_ (range 100)] (take 5 (group-seq-strict #(str \&quot;hello\&quot; %) (range 10000)))))&quot; &quot;(replace \&quot;color is red\&quot; #\&quot;red\&quot; \&quot;\&quot;)&quot; &quot;(replace \&quot;color is red\&quot; #\&quot;red\&quot; \&quot;blue\&quot;)&quot; &quot;(use 'clojure.string/replace)&quot; &quot;(clojure.string/replace \&quot;color is red\&quot; #\&quot;red\&quot; \&quot;blue\&quot;)&quot; &quot;(clojure.string/replace \&quot;color is red\&quot; #\&quot;redd\&quot; \&quot;blue\&quot;)&quot; &quot;(defn trim-dots\n  \&quot;Remoes all trailing __dots__ from a string\&quot;\n  [s]\n  (clojure.string/replace s #\&quot;\\.+$\&quot; \&quot;\&quot;))&quot; &quot;(trim-dots \&quot;you.....\&quot;)&quot; &quot;(numbered [1 99 999])&quot; &quot;(defn numbered\n  [coll]\n  (map vector (range) coll))\n(numbered [1 99 999])&quot; &quot;(arg-value :a :b :c :d)&quot; &quot;(defn arg-value\n  ([args opt-key] (arg-value args opt-key nil))\n  ([args opt-key default]\n   (let [opt-str (str \&quot;--\&quot; (name opt-key))]\n     (if-let [opt (first (filter #(.startsWith % opt-str) args))]\n       (second (string/split opt #\&quot;=\&quot;))\n       default))))\n(arg-value :a :b :c :d)&quot; &quot;(name \&quot;s\&quot;)&quot; &quot;(name :s)&quot; &quot;(name [\&quot;a\&quot;])&quot; &quot;(arg-value [:a :b] :c)&quot; &quot;(defn arg-value\n  ([args opt-key] (arg-value args opt-key nil))\n  ([args opt-key default]\n   (let [opt-str (str \&quot;--\&quot; (name opt-key))]\n     (if-let [opt (first (filter #(.startsWith % opt-str) args))]\n       (second (string/split opt #\&quot;=\&quot;))\n       default))))\n(arg-value [:a :b] :c)&quot; &quot;(arg-value [\&quot;--a\&quot; \&quot;--b\&quot; \&quot;--c\&quot;] :c)&quot; &quot;(defn arg-value\n  ([args opt-key] (arg-value args opt-key nil))\n  ([args opt-key default]\n   (let [opt-str (str \&quot;--\&quot; (name opt-key))]\n     (if-let [opt (first (filter #(.startsWith % opt-str) args))]\n       (second (string/split opt #\&quot;=\&quot;))\n       default))))&quot; &quot;(defn arg-value\n  ([args opt-key] (arg-value args opt-key nil))\n  ([args opt-key default]\n   (let [opt-str (str \&quot;--\&quot; (name opt-key))]\n     (if-let [opt (first (filter #(.startsWith % opt-str) args))]\n       (second (clojure.string/split opt #\&quot;=\&quot;))\n       default))))\n(arg-value [\&quot;--a\&quot; \&quot;--b\&quot; \&quot;--c\&quot;] :c)&quot; &quot;(defn arg-value\n  ([args opt-key] (arg-value args opt-key nil))\n  ([args opt-key default]\n   (let [opt-str (str \&quot;--\&quot; (name opt-key))]\n     (if-let [opt (first (filter #(.startsWith % opt-str) args))]\n       (second (clojure.string/split opt #\&quot;=\&quot;))\n       default))))&quot; &quot;(str \&quot;--\&quot; :a)&quot; &quot;(arg-value [\&quot;--a\&quot; \&quot;--b\&quot; \&quot;--clojure=1.6.0\&quot;] :c)&quot; &quot;(defn set-diff [a b]\n  [(set/difference a b) (set/difference b a)])&quot; &quot;(arg-value [\&quot;--a\&quot; \&quot;--b\&quot; \&quot;--clojure=1.6.0\&quot;] :clojure)&quot; &quot;(arg-value [\&quot;--a\&quot; \&quot;--b\&quot; \&quot;--clojure=1.6.0\&quot;] \&quot;clojure\&quot; )&quot; &quot;(arg-value [\&quot;--python=3.5\&quot; \&quot;--java=8\&quot; \&quot;--clojure=1.6.0\&quot;] \&quot;clojure\&quot;)&quot; &quot;(arg-value [\&quot;--python=3.5\&quot; \&quot;--java=8\&quot; \&quot;--clojure=1.6.0\&quot;] :clojure)&quot;], :remote []}}</component>
</project>